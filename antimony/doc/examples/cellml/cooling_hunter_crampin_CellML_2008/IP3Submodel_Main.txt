//Created by libAntimony v1.4
model ligand__ligand(t, L)

  // Assignment Rules:
  L := piecewise( Ls / (1.0 + exp(-80.0 * (t - ts - 0.05 ))) , ( t < ts + 0.15) && (t >= ts ), Ls , t >= ts + 0.15 , 0 );

  // Variable initializations:
  Ls = 0.100;
  ts = 10;
end

model GPCR_Cycle__GPCR_Cycle(t, L, Gd, J2, J3, J6)

  // Assignment Rules:
  J2 := kf2 * R * Gd - kr2 * Rg;
  J3 := kf3 * Rl * Gd - kr3 * Rlg;
  J6 := kf6 * Rlg;
  J1 := kf1 * R * L - kr1 * Rl;
  kr1 := kf1 * Kd1;
  kr2 := kf2 * Kd2;
  J4 := kf4 * L * Rg - kr4 * Rlg;
  kr4 := kf4 * Kd4;
  J5 := kf5 * Rlg;

  // Rate Rules:
  R' = -1.0 * J1 - J2;
  Rl' = J1 + J6 - J3;
  Rg' = J2 - J4;
  Rlg' = J3 - J5 + (J4 - J6);
  Rlgp' = J5;

  // Variable initializations:
  kf1 = 0.0003;
  Kd1 = 3.00E-5;
  kf2 = 2.75E-4;
  Kd2 = 27500;
  kf3 = 1.00;
  kr3 = 0.00100;
  kf4 = 0.3;
  Kd4 = 3.00E-5;
  kf5 = 0.0004;
  kf6 = 1.00;
  R = 13.9;
  Rl = 0.00;
  Rg = 5.06;
  Rlg = 0.00;
  Rlgp = 0.00;
end

model IP3Submodel__Galpha_interface(gpcrJ2, gpcrJ3, plcJ5, plcJ6, J_gain_Gd, gpcrJ6, plcJ2, plcJ3, J_gain_Gt)

  // Assignment Rules:
  J_gain_Gd := plcJ5 + plcJ6 - (gpcrJ2 + gpcrJ3);
  J_gain_Gt := gpcrJ6 - (plcJ2 + plcJ3);
end

model Galpha__Galpha(t, Gd, J_gain_Gd, Gt_, J_gain_Gt)

  // Assignment Rules:
  J1 := kf1 * Gt_;

  // Rate Rules:
  Gd' = J1 + J_gain_Gd;
  Gt_' = J_gain_Gt - J1;

  // Variable initializations:
  Gd = 10000;
  Gt_ = 0.00;
  kf1 = 0.150;
end

model PLC_Cycle__PLC_Cycle(t, Pc, Pcg, J2, J3, Gt_, Ca, J1, J4, J5, J6)

  // Assignment Rules:
  J2 := kf2 * P * Gt_ - kr2 * Pg;
  J3 := kf3 * Pc * Gt_ - kr3 * Pcg;
  J1 := kf1 * P * Ca - kr1 * Pc;
  J4 := kf4 * Pg * Ca - kr4 * Pcg;
  J5 := kf5 * Pcg;
  J6 := kf6 * Pg;
  kr4 := kf4 * Kd4;

  // Rate Rules:
  Pc' = J1 + J5 - J3;
  Pcg' = J3 + J4 - J5;
  P' = J6 - (J2 + J1);
  Pg' = J2 - (J4 + J6);

  // Variable initializations:
  Pc = 9.09;
  Pcg = 0.00;
  kf1 = 0.0167;
  kr1 = 0.0167;
  kf2 = 0.00420;
  kr2 = 1.00;
  kf3 = 0.0420;
  kr3 = 1.00;
  kf4 = 0.0334;
  Kd4 = 0.1;
  kf5 = 6.00;
  kf6 = 6.00;
  P = 90.9;
  Pg = 0.00;
end

model calcium__calcium(t, Ca, J_gain_Ca)

  // Rate Rules:
  Ca' = J_gain_Ca;

  // Variable initializations:
  Ca = 0.100;
end

model IP3Submodel__calcium_interface(J_gain_Ca, Cpc, plcJ1, plcJ4)

  // Assignment Rules:
  J_gain_Ca := Cpc * (-1 * (plcJ1 + plcJ4));
end

model PIP2__PIP2(Eb, Es, Cpc, J1, J2)

  // Assignment Rules:
  J1 := kf1 * Eb * PIP2 / (Km1 / Cpc + PIP2);
  J2 := kf2 * Es * PIP2 / (Km2 / Cpc + PIP2);

  // Variable initializations:
  PIP2 = 4000;
  kf1 = 0.444;
  Km1 = 19.8;
  kf2 = 3.8;
  Km2 = 5.00;
end

model IP3__IP3(t, J_gain_IP3)

  // Rate Rules:
  IP3' = J_gain_IP3;

  // Variable initializations:
  IP3 = 0.0150;
end

model IP3Submodel__IP3_interface(Cpc, J_gain_IP3, pip2J1, pip2J2, IP3degJ)

  // Assignment Rules:
  J_gain_IP3 := Cpc * (pip2J1 + pip2J2) - IP3degJ;
end

model IP3Submodel__geometry(Cpc)

  // Sub-modules, and any changes to those submodules:
  ligand: ligand__ligand(t, L);
  GPCR_Cycle: GPCR_Cycle__GPCR_Cycle(t0, L, Gd, gpcrJ2, gpcrJ3, gpcrJ6);
  Galpha_interface: IP3Submodel__Galpha_interface(gpcrJ2, gpcrJ3, plcJ5, plcJ6, J_gain_Gd, gpcrJ6, plcJ2, plcJ3, J_gain_Gt);
  Galpha: Galpha__Galpha(t1, Gd, J_gain_Gd, Gt_, J_gain_Gt);
  PLC_Cycle: PLC_Cycle__PLC_Cycle(t2, Eb, Es, plcJ2, plcJ3, Gt_, Ca, plcJ1, plcJ4, plcJ5, plcJ6);
  calcium: calcium__calcium(t3, Ca, J_gain_Ca);
  calcium_interface: IP3Submodel__calcium_interface(J_gain_Ca, Cpc, plcJ1, plcJ4);
  PIP2: PIP2__PIP2(Eb, Es, Cpc, J1, J2);
  IP3: IP3__IP3(t4, J_gain_IP3);
  IP3_interface: IP3Submodel__IP3_interface(Cpc, J_gain_IP3, J1, J2, IP3degJ);

  // Assignment Rules:
  Cpc := Cc / Cp;
  Cc := 1 / (Vc * 6.022e2 );
  Cp := 1 / (Vc * Rpc);

  // Variable initializations:
  Vc = 2550;
  Rpc = 4.61;
end

model IP3Submodel__environment(t)

  // Sub-modules, and any changes to those submodules:
  geometry: IP3Submodel__geometry(Cpc);
  geometry.ligand.t is t;
  geometry.GPCR_Cycle.t is t;
  geometry.Galpha.t is t;
  geometry.PLC_Cycle.t is t;
  geometry.calcium.t is t;
  geometry.IP3.t is t;
end

model IP3__IP3_degradation(IP3)

  // Assignment Rules:
  J1 := kf1 * IP3;

  // Variable initializations:
  kf1 = 1.25;
end

model IP3Submodel____main()

  // Sub-modules, and any changes to those submodules:
  environment: IP3Submodel__environment(t);
  IP3_degradation: IP3__IP3_degradation(IP3);
  environment.geometry.IP3_interface.IP3degJ is J1;
  IP3_degradation.J1 is J1;
  environment.geometry.IP3.IP3 is IP3;
end
