#include <cassert>
#include <iostream>
#include <cstdlib>
#include <set>

#include "stringx.h"
#include "sbmlx.h"
#include "unitdef.h"
#include "registry.h"

using namespace std;

UnitDef::UnitDef(std::string name)
  : m_components()
  , m_name(name)
  , m_nameautogenerated(true)
{
  UnitElement ue(name);
  m_components.push_back(ue);
}

void UnitDef::SetName(std::string name)
{
  m_name = name;
  m_nameautogenerated = false;
}

void UnitDef::MultiplyUnitDef(UnitDef* unitdef)
{
  m_name = m_name + "_" + unitdef->GetName();
  m_nameautogenerated = true;
  for (size_t ue=0; ue<unitdef->m_components.size(); ue++) {
    AddUnitElement(unitdef->m_components[ue]);
  }
}

void UnitDef::RaiseTo(double pow)
{
  m_name = m_name + "_" + DoubleToString(pow);
  m_nameautogenerated = true;
  for (size_t ue=0; ue<m_components.size(); ue++) {
    double newexp = pow * m_components[ue].GetExponent();
    m_components[ue].SetExponent(newexp);
  }
}

void UnitDef::MultiplyBy(double mult)
{
  m_name = "_" + DoubleToString(mult) + "_" + m_name;
  m_nameautogenerated = true;
  assert(m_components.size() > 0);
  m_components[0].MultiplyBy(mult);
}

void UnitDef::AddUnitElement(const UnitElement& ue)
{
  m_components.push_back(ue);
}

bool UnitDef::GetNameAutoGenerated()
{
  return m_nameautogenerated;
}

bool UnitDef::Matches(UnitDef* unitdef)
{
  if (m_name != unitdef->GetName()) return false;
  return ComponentsMatch(unitdef);
}

set<UnitElement> GetSetFrom(vector<UnitElement> unitelements) {
  set<UnitElement> ret;
  for (size_t ue=0; ue<unitelements.size(); ue++) {
    ret.insert(unitelements[ue]);
  }
  return ret;
}

bool UnitDef::ComponentsMatch(UnitDef* unitdef)
{
  set<UnitElement> orig = GetSetFrom(m_components);
  set<UnitElement> match = GetSetFrom(unitdef->m_components);
  for (set<UnitElement>::iterator origel = orig.begin(); origel != orig.end();) {
    bool foundmatch = false;
    for (set<UnitElement>::iterator matchel = match.begin(); matchel != match.end();) {
      if (origel->Matches(*matchel)) {
        match.erase(matchel);
        foundmatch = true;
        break;
      }
      matchel++;
    }
    if (foundmatch) {
      set<UnitElement>::iterator remove = origel;
      origel++;
      orig.erase(remove);
    }
    else {
      origel++;
    }
  }
  if (orig.size()==0 && match.size()==0) return true;
  return false;
}

bool UnitDef::IsOnlyKind()
{
  set<string> usednames;
  UnitDef* canonical = GetCanonical(usednames);
  if (canonical->m_components.size() > 1) return false;
  if (canonical->m_components.size() == 0) {
    assert(false); //The component list should always be at least one long.
    return false;
  }
  UnitElement ue = canonical->m_components[0];
  if (ue.GetExponent() != 1) return false;
  if (ue.GetMultiplier() != 1) return false;
  if (ue.GetScale() != 0) return false;
  return true;
}


std::string UnitDef::GetName()
{
  return m_name;
}

void UnitDef::Invert()
{
  m_name = "inv_" + m_name;
  for (size_t ue=0; ue<m_components.size(); ue++) {
    m_components[ue].Invert();
  }
}

UnitDef* UnitDef::GetCanonical()
{
  set<string> usednames;
  return GetCanonical(usednames);
}

UnitDef* UnitDef::GetCanonical(set<string> usednames)
{
  bool sbmlkindsonly = true;
  for (size_t ue=0; ue<m_components.size(); ue++) {
    if (!m_components[ue].KindIsCanonical()) {
      sbmlkindsonly = false;
      break;
    }
  }
  if (sbmlkindsonly) return this;
  UnitDef* ret = new UnitDef(m_name);
  for (size_t ue=0; ue<m_components.size(); ue++) {
    if (m_components[ue].KindIsCanonical()) {
      ret->AddUnitElement(m_components[ue]);
    }
    else {
      UnitElement unitelement = m_components[ue];
      string subname = unitelement.GetKind();
      if (usednames.find(subname) != usednames.end()) {
        g_registry.SetError("Loop detected in unit definitions with '" + subname + "'.");
        delete ret;
        return NULL;
      }
      usednames.insert(subname);
      UnitDef* ud = g_registry.GetModule(m_module)->GetUnitDef(unitelement.GetKind());
      if (ud==NULL) {
        g_registry.SetError("Undefined unit definition '" + subname + "'.");
        delete ret;
        return NULL;
      }
      ud = ud->GetCanonical(usednames);
      if (ud==NULL) {
        //Should already have set the error;
        delete ret;
        return NULL;
      }
      ud->MultiplyBy(unitelement.GetMultiplier());
      double ten=10;
      ud->MultiplyBy(pow(ten, unitelement.GetScale()));
      ud->RaiseTo(unitelement.GetExponent());
      ret->MultiplyUnitDef(ud);
    }
  }
  return ret;
}

#ifndef SBML
void UnitDef::AddToSBML(Model* sbmlmod)
{
  UnitDef* canonical = GetCanonical();
  if (canonical==NULL) {
    return;
  }
  if (canonical->IsOnlyKind()) {
      return;
  }
  UnitDefinition* ud = sbmlmod->createUnitDefinition();
  ud->setId(canonical->m_name);
  ud->setName(canonical->m_name);
  for (size_t ue=0; ue<m_components.size(); ue++) {
    //LS DEBUG:  create the Unit objects here.
  }
}
#endif
