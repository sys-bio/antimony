/**
 * This file is designed to be compiled by the 'bison' program with the
 * command:
 *
 * bison -v antimony.ypp
 *
 * The '-v' creates a file called 'antimony.output' which can be examined
 * to piece together the explicit logic of the parser.  The fact that no
 * '-o' option is used means that the default output file (antimony.tab.cpp)
 * will be produced.
 *
 * This command produces the file 'antimony.tab.cpp' which is included
 * explicitly in the antimony distribution.  Automatic creation of this
 * file is not yet incorporated into the CMake system; it must be
 * run by hand before change here will make it into the actual antimony
 * library.
 *
 * Bison v2.4.2 was used to create the .cpp file when this file was
 * first created.  It does not rely on odd features of the bison
 * parser, so other versions should work fine.
 *
 * This file currently compiles with zero reduce/reduce errors and 10
 * shift/reduce warnings.
 */

%{
  //#define YYSTYPE double
#include <cassert>
#include <ctype.h>
#include <fstream>
#include <iostream>
#include <math.h>
#include <set>
#include <stdio.h>
#include <string>
#include <utility>
#ifndef NSBML
#include <sbml/SBMLTypes.h>
#endif
#include "registry.h"
#include "module.h"
#include "unitdef.h"
#include "stringx.h"

  class Formula;
  class ReactantList;
  class AntimonyReaction;
  class Variable;

  using namespace std;
  int antimony_yylex(void);
  void antimony_yyerror(char const *);
  Registry g_registry;
  int antimony_yylloc_first_line = 1;
  int antimony_yylloc_last_line = 1;
  vector<int> antimony_yylloc_last_lines;
%}

/*Bison declarations */
%union {
  char character;
  const string* word;
  double num;
  int integer;
  bool is_integer;
  rd_type reactionDivider;
  Formula* formula;
  Formula* spacedformula;
  Formula* commaformula;
  Module* module;
  ReactantList* reactantList;
  Variable* variable;
  Variable* variablein;
  Variable* varmaybeis;
  Variable* maybein;
  Variable* unitdef;
  bool maybemain;
  bool maxormin;
  constraint_type inequality;
  std::vector<std::string>* stringlist;
  std::vector<std::string>* urilist;
}

%type <character>       mathThing "mathematical symbol"
%type <formula>         formula spacedformula commaformula
%type <module>          module
%type <reactantList>    reactantList
%type <reactionDivider> reactionDivider
%type <inequality>      inequality    
%type <variable>        variable variablein varmaybein varmaybeis maybein unitdef
%type <maybemain>       maybemain
%type <maxormin>        maxormin
%type <stringlist>      stringlist

%left '&' '|' /* Boolean functions and, or */
%left '-' '+'
%left '*' '/' '%'
%right '^'    /* exponentiation        */

// dot takes prec over $, e.g. in $mymodel.species, mymodel.species is reduced first and then turned into a boundary species (e.g. in comp)
%precedence '$'
%precedence '.'

%token YYEOF 0 "end of file"
%token EOL "end of line"
%token  <num> NUM "number"
%token  <word> AFTER "'after'"
%token  <word> ANTWORD "element name"
%token  <word> AT "'@' or 'at'"
%token  <word> BECOMESREV "->"
%token  <word> BECOMESINH "-|"
%token  <word> BECOMESMOD "-("
%token  <word> BECOMESMOD2 "-o"
%token  <word> BECOMESIRREV "=>"
%token  <word> COMPARTMENT "'compartment'"
%token  <word> CONSTANT "name of a pre-defined constant"
%token  <word> CONSTRAINTWORD "'constraint'"
%token  <word> CONSTWORD "'const'"
%token  <word> DASHES "--"
%token  <word> DELETEWORD "'delete'"
%token  <word> DNA "'DNA'"
%token  <word> ELLIPSES "..."
%token  <word> END "'end'"
%token  <word> ERROR "an error"
%token  <word> EVENT "'event'"
%token  <word> FORMULA "'formula'"
%token  <word> FUNCTION "name of an existing function"
%token  <word> FUNCTIONWORD "'function'"
%token  <word> GENE "'gene'"
%token  <word> HASWORD "'has'"
%token  <word> IMPORT "'import'"
%token  <word> INWORD "'in'"
%token  <word> IS "'is'"
%token  <word> MAXIMIZEWORD "'maximize'"
%token  <word> MINIMIZEWORD "'minimize'"
%token  <word> MODNAME "name of an existing module"
%token  <word> MODULE "'model' or 'module'"
%token  <word> OPERATOR "'operator'"
%token  <word> REACTION "'reaction'"
%token  <word> SPECIES "'species'"
%token  <word> SUBSTONLY "'substanceOnly'"
%token  <word> TEXTSTRING "text string"
%token  <word> UNITWORD "'unit'"
%token  <word> VARWORD "'var'"
//                      %token  <word> DELETEWORD "'delete'"

%name-prefix="antimony_yy"
%debug
%error-verbose
%% /* The grammar: */

input:          /* empty */
        |       input import {}
        |       input module { /*cout << endl << $2->ToString() << endl << endl;*/ }
        |       input modulepart {}
        |       input function {}
        |       input modulename {}
        |       input functionname {}
        |       input modulecvterm {}
        |       input functioncvterm {}
        |       input toplevel_sbo {}
        |       input error {YYABORT;}
        |       input ERROR {YYABORT;}
        ;

import:         IMPORT TEXTSTRING { if (g_registry.OpenFile(*($2))==0) YYABORT;}
        ;

        // causes too much trouble
        // JKM set module name in declaration
// module:         MODULE maybemain ANTWORD IS TEXTSTRING {g_registry.NewCurrentModule($3, $5, $2);} '(' variableexportlist ')' lineend modulebody END
//                 {
//                   $$ = g_registry.CurrentModule();
//                   if ($$->Finalize()) YYABORT;
//                   g_registry.RevertToPreviousModule();
//                 }
//         // JKM set module name in declaration
//         |       MODULE maybemain ANTWORD IS TEXTSTRING {g_registry.NewCurrentModule($3, $5, $2);} lineend modulebody END
//                 {
//                   $$ = g_registry.CurrentModule();
//                   if ($$->Finalize()) YYABORT;
//                   g_registry.RevertToPreviousModule();
//                 }
module:         MODULE maybemain ANTWORD {g_registry.NewCurrentModule($3, NULL, $2);} '(' variableexportlist ')' modulebody END
                {
                  $$ = g_registry.CurrentModule();
                  if ($$->Finalize()) YYABORT;
                  g_registry.RevertToPreviousModule();
                }
        |       MODULE maybemain ANTWORD {g_registry.NewCurrentModule($3, NULL, $2);} modulebody END
                {
                  $$ = g_registry.CurrentModule();
                  if ($$->Finalize()) YYABORT;
                  g_registry.RevertToPreviousModule();
                }
        |       MODULE MODNAME {g_registry.SetError("module '" + *($2) + "' already defined."); YYABORT;}
        |       MODULE FUNCTION {g_registry.SetError("Cannot define '" + *($2) + "' as a module because it is already a defined function."); YYABORT;} 
        ;

maybemain:      /* empty */ {$$ = false;}
        |       '*' {$$ = true;}
        ;

function:       FUNCTIONWORD ANTWORD {g_registry.NewUserFunction($2);} '(' variableexportlist ')' spacedformula END {if (g_registry.SetUserFunction($7)) YYABORT;}
        |       FUNCTIONWORD MODNAME {g_registry.SetError("Cannot use '" + *($2) +"' as a function name because it is already the name of a module."); YYABORT;}
        |       FUNCTIONWORD FUNCTION {g_registry.SetError("Cannot define '" + *($2) + "' as a new function because it is already a defined function."); YYABORT;} 
        ;

spacedformula:  formula {$$ = $1;}
        |       lineend spacedformula {$$ = $2;}
        |       spacedformula lineend {$$ = $1;}
        ;

/*
maybelineend:   // empty
        |       lineend {}
        ;
*/

variableexportlist:
                /* empty */ {}
        |       variable {if (g_registry.AddVariableToCurrentExportList($1)) YYABORT; }
        |       variableexportlist ',' variable { if (g_registry.AddVariableToCurrentExportList($3)) YYABORT; }
        ;

variable:       ANTWORD {$$ = g_registry.AddVariableToCurrent($1); }
        |       variable '.' ANTWORD {$$ = $1->GetSubVariable($3);
                  if ($$ == NULL) {
                    g_registry.SetError("'" + *($3) + "' is not a subvariable of '" + $1->GetNameDelimitedBy(".") + "'.");
                    YYABORT;
                  }
                }
        |       '$' variable {$$ = $2; if ($$->SetIsConst(true)) YYABORT;}
        ;

variablein:     variable INWORD variable {if ($1->SetCompartment($3)) YYABORT; $$ = $1;}
        ;

varmaybein:     variable {$$ = $1;}
        |       variablein {$$ = $1;}
        ;

varmaybeis:     varmaybein {$$ = $1;}
        |       varmaybein '=' formula {$$ = $1; if ($1->SetFormula($3)) YYABORT; }
        |       varmaybein ':' '=' formula {$$ = $1; if ($1->SetAssignmentRule($4)) YYABORT; }
        |       varmaybein '\'' '=' formula {$$ = $1; if ($1->SetRateRule($4)) YYABORT; }
        |       varmaybein HASWORD unitdef {$$ = $1; if ($1->SetUnit($3)) YYABORT; }
        ;

maybein:        /* empty */ {$$ = NULL;}
        |       INWORD variable {$$ = $2;}
        ;

modulebody:     modulepart {}
        |       modulebody modulepart {}
        ;

modulepart:     reaction lineend {}
        |       assignment lineend {}
        |       submodule lineend {}
        |       varinitialize lineend {}
        |       dnadef lineend {}
        |       event lineend {}
        |       unitinit lineend {}
        |       deletion lineend {}
        |       cvterm lineend {}
        |       variablein {}
        |       constraint lineend {}
        |       objective lineend {}
        |       lineend {}
        ;

reaction:       varmaybein ':' reactantList reactionDivider reactantList ';' formula maybein
                {
                  Variable* var = g_registry.AddNewReactionToCurrent($4, $7, $1);
                  if (var == NULL) YYABORT;
                  if ($8 != NULL) {
                    if ($1->SetCompartment($8)) YYABORT;
                  }
                }
        |       reactantList reactionDivider reactantList ';' formula maybein
                {
                  Variable* var = g_registry.AddNewReactionToCurrent($2, $5);
                  if (var == NULL) YYABORT;
                  if ($6 != NULL) {
                    if (var->SetCompartment($6)) YYABORT;
                  }
                }
        ;

reactantList:   /* empty */ {$$ = g_registry.NewBlankReactantList(); }
        |       variable {$$ = g_registry.NewBlankReactantList(); $$->AddReactant($1); }
        |       NUM variable {$$ = g_registry.NewBlankReactantList(); $$->AddReactant($2, $1); }
        |       reactantList '+' variable {$$ = $1; $1->AddReactant($3); }
        |       reactantList '+' NUM variable {$$ = $1; $1->AddReactant($4, $3); }
        ;

reactionDivider:
                BECOMESREV {$$ = rdBecomes;}
        |       BECOMESINH {$$ = rdInhibits;}
        |       BECOMESMOD {$$ = rdInfluences;}
        |       BECOMESMOD2 {$$ = rdInfluences;}
//         |       '-' ANTWORD {if (*$2 != "o") {g_registry.SetError("'-" + *$2 + "' is not a valid set of characters to demark reactions.  Try '->' for reactions, and '-|', '-o', and '-(' for interactions."); YYABORT;} $$ = rdActivates;}
        |       BECOMESIRREV {$$ = rdBecomesIrreversibly;}
        |       '<' BECOMESIRREV {$$ = rdBecomes;}
        ;

formula:        /* empty */ {$$ = g_registry.NewBlankFormula(); }
        |       formula ELLIPSES {$$ = $1; $1->AddEllipses();}
        |       formula variable {$$ = $1; $1->AddVariable($2); }
        |       formula NUM  {$$ = $1; $1->AddNum($2); }
        |       formula CONSTANT  {$$ = $1; $1->AddText($2); }
        |       formula FUNCTION {$$ = $1; $1->AddText($2); }
        |       formula '(' commaformula ')' {$$ = $1; $3->AddParentheses(); $$->AddFormula($3); }
        |       formula mathThing {$$ = $1; $1->AddMathThing($2); }
        |       formula '<' '=' {$$ = $1; $1->AddMathThing('<'); $1->AddMathThing('='); }
        |       formula '>' '=' {$$ = $1; $1->AddMathThing('>'); $1->AddMathThing('='); }
        |       formula '=' '=' {$$ = $1; $1->AddMathThing('='); $1->AddMathThing('='); }
        |       formula '!' '=' {$$ = $1; $1->AddMathThing('!'); $1->AddMathThing('='); }
        |       formula '&' '&' {$$ = $1; $1->AddMathThing('&'); $1->AddMathThing('&'); }
        |       formula '|' '|' {$$ = $1; $1->AddMathThing('|'); $1->AddMathThing('|'); }
        |       formula '{' unitdef '}'
                {
                  //Need to create a variable to be this unit definition, or find one that already has this unit definition, and then use that name.
                  $$ = $1;
                  $$->AddVariable($3);
                }
        ;

commaformula:   formula {$$ = $1;}
        |       commaformula ',' formula {$$ = $1; $$->AddMathThing(','); $$->AddFormula($3); }
        ;

mathThing:      '+' {$$ = '+';}
        |       '-' {$$ = '-';}
        |       '*' {$$ = '*';}
        |       '/' {$$ = '/';}
        |       '^' {$$ = '^';}
        |       '>' {$$ = '>';}
        |       '<' {$$ = '<';}
        |       '!' {$$ = '!';}
        |       '%' {$$ = '%';}
        ;

lineend:        ';' {}
        |       '\n' {}
        |       EOL {}
        ;

assignment:     varmaybein ':' maxormin formula {if (g_registry.CurrentModule()->AddObjective($1, $4, $3)) YYABORT;}
        |       varmaybein '=' formula {if ($1->SetFormula($3)) YYABORT; }
        |       varmaybein IS variable {if ($1->Synchronize($3, NULL)) YYABORT;}
        |       varmaybein IS variable '/' variable {if ($1->Synchronize($3, $5)) YYABORT;}
        |       varmaybein '*' variable IS variable {if ($1->Synchronize($5, $3)) YYABORT;}
        |       varmaybein IS TEXTSTRING {if ($1->SetDisplayName(*($3))) YYABORT;}
        |       varmaybein ':' '=' formula {if ($1->SetAssignmentRule($4)) YYABORT;}
        |       varmaybein '\'' '=' formula {if ($1->SetRateRule($4)) YYABORT;}
        |       varmaybein HASWORD unitdef {if ($1->SetUnit($3)) YYABORT; }
//        |       NUM '=' formula {if (g_registry.CurrentModule()->SetAlgRule($1, $3)) YYABORT; }
        ;

submodule:      varmaybein ':' MODNAME '(' {if ($1->SetModule($3)) YYABORT;} variableimportlist ')' submodifications maybein {if ($9 != NULL) {if ($1->SetCompartment($9)) YYABORT;}}
        |       MODNAME '(' {if(g_registry.CurrentModule()->SetModule($1)) YYABORT;} variableimportlist ')' submodifications maybein {if ($7 != NULL) {if (g_registry.GetCurrentSubmodel()->SetCompartment($7)) YYABORT;}}
        ;

variableimportlist:
                /* empty */ {}
        |       variable {if (g_registry.AddVariableToCurrentImportList($1)) YYABORT; }
        |       variableimportlist ',' variable { if (g_registry.AddVariableToCurrentImportList($3)) YYABORT; }
        |       NUM {if (g_registry.AddNumberToCurrentImportList($1)) YYABORT; }
        |       variableimportlist ',' NUM { if (g_registry.AddNumberToCurrentImportList($3)) YYABORT; }
        ;

submodifications:
                /* empty */ {}
        |       submodifications ',' ANTWORD '=' variable {if (CaselessStrCmp(*$3, "extentconv")) {g_registry.GetCurrentSubmodel()->SetExtentConversionFactor($5);}
                else if (CaselessStrCmp(*$3, "timeconv")) {if (g_registry.GetCurrentSubmodel()->SetTimeConversionFactor($5)) YYABORT;}
                else { g_registry.SetError("Illegal term '" + *$3 + "' in submodel declaration.  You may use the terms 'extentconv' and 'timeconv' to set the extent and time conversion factors for this submodel, respectively."); YYABORT;}}
        ;
        |       submodifications ',' ANTWORD '=' NUM {if (CaselessStrCmp(*$3, "extentconv")) {g_registry.GetCurrentSubmodel()->SetExtentConversionFactor($5);}
                else if (CaselessStrCmp(*$3, "timeconv")) {if (g_registry.GetCurrentSubmodel()->SetTimeConversionFactor($5)) YYABORT;}
                else { g_registry.SetError("Illegal term '" + *$3 + "' in submodel declaration.  You may use the terms 'extentconv' and 'timeconv' to set the extent and time conversion factors for this submodel, respectively."); YYABORT;}}
        ;
varinitialize:  specinit { }
        |       formulainit { }
        |       reactioninit { }
        |       dnainit { }
        |       geneinit { }
        |       operatorinit { }
//        |       eventinit { }
        |       compartmentinit { }
        |       varconstinit { }
        ;

specinit:       SPECIES varmaybeis {g_registry.SetConstness(constDEFAULT); g_registry.SetSubstOnly(false); $2->SetRegSpecVals(); if ($2->SetType(varSpeciesUndef)) YYABORT; }
        |       VARWORD SPECIES varmaybeis {g_registry.SetConstness(constVAR); g_registry.SetSubstOnly(false); $3->SetRegSpecVals(); if ($3->SetType(varSpeciesUndef)) YYABORT; }
        |       CONSTWORD SPECIES varmaybeis {g_registry.SetConstness(constCONST); g_registry.SetSubstOnly(false); $3->SetRegSpecVals(); if ($3->SetType(varSpeciesUndef)) YYABORT; }
        |       SUBSTONLY SPECIES varmaybeis {g_registry.SetConstness(constDEFAULT); g_registry.SetSubstOnly(true); $3->SetRegSpecVals(); if ($3->SetType(varSpeciesUndef)) YYABORT; }
        |       SUBSTONLY varmaybeis {g_registry.SetConstness(constDEFAULT); g_registry.SetSubstOnly(true); $2->SetRegSpecVals(); if ($2->SetType(varSpeciesUndef)) YYABORT; }
        |       VARWORD SUBSTONLY SPECIES varmaybeis {g_registry.SetConstness(constVAR); g_registry.SetSubstOnly(true); $4->SetRegSpecVals(); if ($4->SetType(varSpeciesUndef)) YYABORT; }
        |       CONSTWORD SUBSTONLY SPECIES varmaybeis {g_registry.SetConstness(constCONST); g_registry.SetSubstOnly(true); $4->SetRegSpecVals(); if ($4->SetType(varSpeciesUndef)) YYABORT; }
        |       specinit ',' varmaybeis {$3->SetRegSpecVals(); if ($3->SetType(varSpeciesUndef)) YYABORT; }
        ;

formulainit:    FORMULA varmaybeis {g_registry.SetConstness(constDEFAULT); $2->SetRegConst(); if ($2->SetType(varFormulaUndef)) YYABORT; }
        |       VARWORD FORMULA varmaybeis {g_registry.SetConstness(constVAR); $3->SetRegConst(); if ($3->SetType(varFormulaUndef)) YYABORT; }
        |       CONSTWORD FORMULA varmaybeis {g_registry.SetConstness(constCONST); $3->SetRegConst(); if ($3->SetType(varFormulaUndef)) YYABORT; }
        |       formulainit ',' varmaybeis {$3->SetRegConst(); if ($3->SetType(varFormulaUndef)) YYABORT; }
        ;

reactioninit:   REACTION varmaybeis {g_registry.SetConstness(constDEFAULT); $2->SetRegConst(); if ($2->SetType(varReactionUndef)) YYABORT; }
        |       VARWORD REACTION varmaybeis {g_registry.SetConstness(constVAR); $3->SetRegConst(); if ($3->SetType(varReactionUndef)) YYABORT; }
        |       CONSTWORD REACTION {g_registry.SetError("Reactions may not be set 'const'."); YYABORT; }
        |       reactioninit ',' varmaybeis {$3->SetRegConst(); if ($3->SetType(varReactionUndef)) YYABORT; }
        ;

dnainit:        DNA varmaybeis {g_registry.SetConstness(constDEFAULT); $2->SetRegConst(); if ($2->SetType(varDNA)) YYABORT; }
        |       VARWORD DNA varmaybeis {g_registry.SetConstness(constVAR); $3->SetRegConst(); if ($3->SetType(varDNA)) YYABORT; }
        |       CONSTWORD DNA varmaybeis {g_registry.SetConstness(constCONST); $3->SetRegConst(); if ($3->SetType(varDNA)) YYABORT; }
        |       dnainit ',' varmaybeis {$3->SetRegConst(); if ($3->SetType(varDNA)) YYABORT; }
        ;

geneinit:       GENE varmaybeis {g_registry.SetConstness(constDEFAULT); $2->SetRegConst(); if ($2->SetType(varReactionGene)) YYABORT; }
        |       VARWORD GENE varmaybeis {g_registry.SetConstness(constVAR); $3->SetRegConst(); if ($3->SetType(varReactionGene)) YYABORT; }
        |       CONSTWORD GENE varmaybeis {g_registry.SetError("Genes may not be set 'const'."); YYABORT; }
        |       geneinit ',' varmaybeis {$3->SetRegConst(); if ($3->SetType(varReactionGene)) YYABORT; }
        ;

operatorinit:   OPERATOR varmaybeis {g_registry.SetConstness(constDEFAULT); $2->SetRegConst(); if ($2->SetType(varFormulaOperator)) YYABORT; }
        |       VARWORD OPERATOR varmaybeis {g_registry.SetConstness(constVAR); $3->SetRegConst(); if ($3->SetType(varFormulaOperator)) YYABORT; }
        |       CONSTWORD OPERATOR varmaybeis {g_registry.SetConstness(constCONST); $3->SetRegConst(); if ($3->SetType(varFormulaOperator)) YYABORT; }
        |       operatorinit ',' varmaybeis {$3->SetRegConst(); if ($3->SetType(varFormulaOperator)) YYABORT; }
        ;

compartmentinit:
                COMPARTMENT varmaybeis {g_registry.SetConstness(constDEFAULT); $2->SetRegConst(); if ($2->SetType(varCompartment)) YYABORT; }
        |       VARWORD COMPARTMENT varmaybeis {g_registry.SetConstness(constVAR); $3->SetRegConst(); if ($3->SetType(varCompartment)) YYABORT; }
        |       CONSTWORD COMPARTMENT varmaybeis {g_registry.SetConstness(constCONST); $3->SetRegConst(); if ($3->SetType(varCompartment)) YYABORT; }
        |       compartmentinit ',' varmaybeis {$3->SetRegConst(); if ($3->SetType(varCompartment)) YYABORT; }
        ;

varconstinit:   VARWORD varmaybeis {g_registry.SetConstness(constVAR); $2->SetRegConst();}
        |       CONSTWORD varmaybeis {g_registry.SetConstness(constCONST); $2->SetRegConst();}
        |       varconstinit ',' varmaybeis {$3->SetRegConst();}
        ;

unitinit:       UNITWORD variable '=' formula {if ($2->SetType(varUnitDefinition)) YYABORT;
                                               if ($4->MakeAllVariablesUnits()) YYABORT;
                                               if ($2->GetUnitDef()->SetFromFormula($4)) YYABORT;}
        |       UNITWORD variable {if ($2->SetType(varUnitDefinition)) YYABORT;} 
        ;

dnadef:         dnastrand {if (g_registry.SaveWorkingStrand()) YYABORT;}
        |       varmaybein ':' dnastrand {if (g_registry.SetStrandAs($1)) YYABORT;}
        ;

dnastrand:      DASHES variable {if (g_registry.SetNewUpstreamOpen($2)) YYABORT;}
        |       DASHES dnamiddle {g_registry.SetOpenUpstream(); }
        |       dnamiddle variable {if (g_registry.SetDownstreamEnd($2)) YYABORT;}
        |       DASHES dnamiddle variable {g_registry.SetOpenUpstream(); if(g_registry.SetDownstreamEnd($3)) YYABORT;}
        |       dnamiddle { }
        ;

dnamiddle:      variable DASHES {if (g_registry.SetNewDownstreamOpen($1)) YYABORT;}
        |       dnamiddle variable DASHES {if (g_registry.SetDownstreamOpen($2)) YYABORT;}
        ;

event:          AT formula {if (g_registry.SetNewCurrentEvent($2)) YYABORT;} eventmodifications colonret assignmentlist {}
        |       AT formula AFTER formula {if (g_registry.SetNewCurrentEvent($2, $4)) YYABORT;} eventmodifications colonret assignmentlist {}
        |       varmaybein ':' AT formula {if (g_registry.SetNewCurrentEvent($4, $1)) YYABORT;}  eventmodifications colonret assignmentlist {}
        |       varmaybein ':' AT formula AFTER formula {if (g_registry.SetNewCurrentEvent($4, $6, $1)) YYABORT;} eventmodifications colonret assignmentlist {}
        ;

colonret:       ':' {}
        |       colonret '\n' {}
        ;

eventmodifications:  /* empty */ {}
        |       eventmodifications ',' ANTWORD '=' formula {if (CaselessStrCmp(*$3, "priority")) {g_registry.GetCurrentEvent()->SetPriority(*$5);}
                else if (CaselessStrCmp(*$3, "t0")) {if (g_registry.GetCurrentEvent()->SetInitialValue(*$5)) YYABORT;}
                else if (CaselessStrCmp(*$3, "fromTrigger")) {if (g_registry.GetCurrentEvent()->SetUseValuesFromTriggerTime(*$5)) YYABORT;}
                else if (CaselessStrCmp(*$3, "persistent")) {if (g_registry.GetCurrentEvent()->SetPersistent(*$5)) YYABORT;}
                else { g_registry.SetError("Illegal term '" + *$3 + "' in event defintion.  You may use the terms 'priority', 't0', 'fromTrigger', and 'persistent' here to set those properties of an event."); YYABORT;}}
        ;

assignmentlist: variable '=' formula {if (g_registry.GetCurrentEvent()->AddResult($1, $3)) YYABORT;}
        |       variable '=' formula ':' assignmentlist {if (g_registry.GetCurrentEvent()->AddResult($1, $3)) YYABORT;}
        |       variable '=' formula ':' '\n' assignmentlist {if (g_registry.GetCurrentEvent()->AddResult($1, $3)) YYABORT;}
        |       variable '=' formula ',' assignmentlist {if (g_registry.GetCurrentEvent()->AddResult($1, $3)) YYABORT;}
        |       variable '=' formula ',' '\n' assignmentlist {if (g_registry.GetCurrentEvent()->AddResult($1, $3)) YYABORT;}
        ;

deletion:       DELETEWORD variable {if (g_registry.CurrentModule()->AddDeletion($2)) YYABORT;}
        |       deletion ',' variable {if (g_registry.CurrentModule()->AddDeletion($3)) YYABORT;}
        ;

unitdef:        formula {
                    if ($1->MakeAllVariablesUnits()) YYABORT;
                    if ($1->IsSingleVariable()) {
                      $$ = g_registry.CurrentModule()->GetVariable(($1->GetVariables())[0]);
                      if ($$==NULL) YYABORT;
                    }
                    else {
                      UnitDef* ud = new UnitDef("", g_registry.CurrentModule()->GetModuleName());
                      if ($1->MakeAllVariablesUnits()) YYABORT;
                      if (ud->SetFromFormula($1)) YYABORT;
                      $$ = g_registry.CurrentModule()->AddOrFindUnitDef(ud);
                    }
                }
        ;

constraint:     NUM inequality formula {if (g_registry.CurrentModule()->AddConstraint($1, $3, $2)) YYABORT;}
        |       '-' NUM inequality formula {if (g_registry.CurrentModule()->AddConstraint(-$2, $4, $3)) YYABORT;}
        |       CONSTANT inequality formula {if (g_registry.CurrentModule()->AddConstraint($1, $3, $2)) YYABORT;}
        |       ANTWORD inequality formula {if (g_registry.CurrentModule()->AddConstraint($1, $3, $2)) YYABORT;}
        |       CONSTRAINTWORD ':' formula {if (g_registry.CurrentModule()->AddConstraint($3)) YYABORT;}
        |       CONSTRAINTWORD variable ':' formula {if (g_registry.CurrentModule()->AddConstraint($2, $4)) YYABORT;}
        ;

inequality:     '<' {$$ = constLT;}
        |       '<' '=' {$$ = constLEQ;}
        |       '>' {$$ = constGT;}
        |       '>' '=' {$$ = constGEQ;}
        |       '!' '=' {$$ = constNEQ;}
        ;

objective:      maxormin formula              {if (g_registry.CurrentModule()->AddObjective($2, $1)) YYABORT;}
        ;

maxormin:       MAXIMIZEWORD {$$ = true;}
        |       MINIMIZEWORD {$$ = false;}
        ;

stringlist:     TEXTSTRING { $$ = new std::vector<std::string>(); $$->push_back(*($1)); } // need to free $1?
        |       stringlist ',' TEXTSTRING { $$ = $1; $$->push_back(*$3); } // need to free $3?
        |       stringlist ',' '\n' TEXTSTRING { $$ = $1; $$->push_back(*$4); } // eat newlines

// urilist:        URI { $$ = new std::vector<std::string>(); $$->push_back(*($1)); } // need to free $1?
//         |       urilist ',' URI { $$ = $1; $$->push_back(*$3); } // need to free $3?
//         |       urilist ',' '\n' URI { $$ = $1; $$->push_back(*$4); } // eat newlines

// JKM cvterm accepts multiple URIs in the stringlist
cvterm:         variable ANTWORD stringlist {if (g_registry.CurrentModule()->ProcessCVTerm($1,$2,$3)) YYABORT;}

// JKM setting an SBO term for a module (outside the body of the module)
toplevel_sbo:     MODNAME '.' ANTWORD '=' NUM
                  { Module* module = g_registry.GetModule(*$1);
                    if (module && $3 && *($3) == "sboTerm") {
                      module->SetSBOTerm($5);
                    }
                  }
// JKM setting an SBO term for a function (outside the body of the function)
        |         FUNCTION '.' ANTWORD '=' NUM
                  { Module* function = g_registry.GetModule(*$1);
                    if (function && $3 && *($3) == "sboTerm") {
                      function->SetSBOTerm($5);
                    }
                  }

// JKM for naming modules and functions (display names)
modulename:     MODNAME IS TEXTSTRING lineend
                { Module* module = g_registry.GetModule(*$1);
                  if (module && $3) {
                    module->SetDisplayName(*$3);
                  }
                }
functionname:   FUNCTION IS TEXTSTRING lineend
                { Module* function = g_registry.GetModule(*$1);
                  if (function && $3) {
                    function->SetDisplayName(*$3);
                  }
                }

// JKM for parsing cv terms for modules and functions
modulecvterm:   MODNAME ANTWORD stringlist lineend {if (g_registry.ProcessGlobalCVTerm($1,$2,$3)) YYABORT;}
functioncvterm: FUNCTION ANTWORD stringlist lineend {if (g_registry.ProcessGlobalCVTerm($1,$2,$3)) YYABORT;}

%%


void antimony_yyerror(char const *s)
{
  if (g_registry.GetError()=="") {
    g_registry.SetError(s);
  }
}

void putback_string(const string& s)
{
  for(unsigned int i=s.size(); i>0; --i)
    g_registry.input->putback(s.at(i-1));
}

bool is_whitespace(const char cc)
{
  if (cc == '\r' || cc == '\n' || cc == ' ' || cc == '\t')
    return true;
  else
    return false;
}

string eat_whitespace()
{
  char cc = 0;
  g_registry.input->get(cc);
  string result;
  while (is_whitespace(cc) && !g_registry.input->eof()) {
    result += cc;
    g_registry.input->get(cc);
  }
  g_registry.input->unget();
  return result;
}

// consumes everything up to and including the eol (win and unix supported)
string consume_rest_of_line()
{
  char cc = 0;
  string result;
  while (!g_registry.input->eof()) {
    g_registry.input->get(cc);
    if (cc == '\r') {
      g_registry.input->get(cc);
      if (cc != '\n') {
        g_registry.input->unget();
      }
      cc = '\n';
    }
    result += cc;
    if (cc == '\n') {
      return result;
    }
  }
  return result;
}

string eat_whitespace_and_comments()
{
  char cc = 0;
  g_registry.input->get(cc);
  string result;
  while ((is_whitespace(cc) || cc == '/' || cc == '#')&& !g_registry.input->eof()) {
    result += cc;
    if (cc == '/') {
      g_registry.input->get(cc);
      if (cc == '/')
        result += consume_rest_of_line();
    } else if (cc == '#') {
      result += consume_rest_of_line();
    } else
      g_registry.input->get(cc);
  }
  g_registry.input->unget();
  return result;
}

int count_newlines_in(const string& s)
{
  int result=0;
  for(string::const_iterator i(s.begin()); i!=s.end(); ++i) {
    if (*i == '\r' || *i == '\n')
      ++result;
  }
  return result;
}

bool is_word_char(const char cc)
{
  if (cc > 0 && (isalpha(cc) || isdigit(cc) || cc == '_'))
    return true;
  else
    return false;
}

// bool is_numeric_char(const char cc)
// {
//   if (cc > 0 && '0' <= cc && cc <= '9')
//     return true;
//   else
//     return false;
// }

// bool is_word_or_numeric_char(const char cc)
// {
//   if (is_word_char(cc) || is_numeric_char(cc))
//     return true;
//   else
//     return false;
// }

// check if it is a valid predicate (e.g.
bool is_valid_prefixed_predicate(const string& prefix, const string& uri)
{
  bool uri_is_numeric = IsNumeric(uri);
  if (CaselessStrCmp(prefix, "bqb")) {
    if (Annotated::isBiomodelsQual(uri))
      return true;
    else
      return false;
  } else if (CaselessStrCmp(prefix, "bqm")) {
    if (Annotated::isBiomodelsQual(uri))
      return true;
    else
      return false;
  } else if (g_registry.IsRegisteredPrefix(prefix))
    // if the prefix is defined it's okay
    return true;
  else
    return false;
}

string make_biomodels_qual_full_uri(const string& predicate)
{
  stringstream ss;
  if (Annotated::DecodeBiolQualifier(predicate) != BQB_UNKNOWN) {
    ss << "https://biomodels.net/biology-qualifiers/" << Annotated::EncodeBiolQualifier(Annotated::DecodeBiolQualifier(predicate));
    return ss.str();
  } else if (Annotated::DecodeModelQualifier(predicate) != BQM_UNKNOWN) {
    ss << "http://biomodels.net/model-qualifiers/" << Annotated::EncodeModelQualifier(Annotated::DecodeModelQualifier(predicate));
    return ss.str();
  } else
    return "";
}

pair<int,string> make_builtin_prefixed_predicate_uri(const string& prefix, const string& predicate)
{
  stringstream ss;
  if (CaselessStrCmp(prefix, "bqb") && Annotated::DecodeModelQualifier(predicate) != BQM_UNKNOWN) {
    ss << "http://biomodels.net/model-qualifiers/" << Annotated::EncodeModelQualifier(Annotated::DecodeModelQualifier(predicate));
    return make_pair(0,ss.str());
  } else if (CaselessStrCmp(prefix, "bqm") && Annotated::DecodeBiolQualifier(predicate) != BQB_UNKNOWN) {
    ss << "https://biomodels.net/biology-qualifiers/" << Annotated::EncodeBiolQualifier(Annotated::DecodeBiolQualifier(predicate));
    return make_pair(0,ss.str());
  } else
    return make_pair(1,"");
}

class PredicateResult
{
public:
  // error condition
  PredicateResult(int e)
    : m_e(e) {}

  // success condition
  PredicateResult(int e, string parsed, string predicate)
    : m_e(e), m_parsed(parsed), m_predicate(predicate) {}

  int getErrorCode() const {
    return m_e;
  }

  const string& getParsedText() const {
    return m_parsed;
  }

  const string& getPredicateAbsoluteURI() const {
    return m_predicate;
  }

  int m_e;
  string m_parsed;
  string m_predicate;
};

// returns zero if it matches a predicate, non-zero otherwise (and puts back everything it read in the latter)
PredicateResult try_parse_predicate()
{
  cerr << "    try_parse_predicate\n";
  char cc = 0;
  g_registry.input->get(cc);
  cerr << "    cc " << cc << "\n";
//   cerr << "      " << cc << "\n";
  // first check if it's a built-in predicate (the biomodels quals) or prefixed predicate
  if (cc > 0 && (isalpha(cc) || cc == '_')) {
    string first_word;
    while (is_word_char(cc) && !g_registry.input->eof()) {
      first_word += cc;
      g_registry.input->get(cc);
    }
    cerr << "    pred " << first_word << "\n";

    // is a prefixed uri?
    if (cc != ':') {
      g_registry.input->unget();
      // is a built-in biomodels qual?
      if (Annotated::isBiomodelsQual(first_word)) {
        string uri = make_biomodels_qual_full_uri(first_word);
        if (uri == "") {
          putback_string(first_word);
          return PredicateResult(1);
        }
        return PredicateResult(0, first_word, uri);
      } else {
        putback_string(first_word);
        return PredicateResult(2);
      }
    }

    // check the prefixed uri
    string second_word;
    g_registry.input->get(cc);
    while (is_word_char(cc) && !g_registry.input->eof()) {
      second_word += cc;
      g_registry.input->get(cc);
    }
    g_registry.input->unget();

    pair<int,string> prefixed_result = make_builtin_prefixed_predicate_uri(first_word, second_word);
    if (!prefixed_result.first) {
      return PredicateResult(0, first_word+":"+second_word, prefixed_result.second);
    } else {
      putback_string(first_word+":"+second_word);
      return PredicateResult(3);
    }
  } else if (cc == '<') {
    // it could be an absolute uri
    string uri;
    while (!is_whitespace(cc) && cc != '>' && !g_registry.input->eof()) {
      uri += cc;
      g_registry.input->get(cc);
    }
    if (cc == '>')
      // it is an absolute uri
      return PredicateResult(0,"<"+uri+">",uri);
    else {
      // it's not an absolute uri
      // we don't know what it is so put everything back
      g_registry.input->unget();
      putback_string("<"+uri);
      return PredicateResult(4);
    }
  } else {
    g_registry.input->unget();
    return PredicateResult(5);
  }
}

class ObjectResult
{
public:
  // error condition
  ObjectResult(int e)
    : m_e(e) {}

  ObjectResult(int e, string parsed, string uri)
    : m_e(e), m_parsed(parsed) {
      m_uris.push_back(uri);
    }

  ObjectResult(int e, string parsed, const vector<string> uris)
    : m_e(e), m_parsed(parsed), m_uris(uris) {}

  ObjectResult combine(const ObjectResult& other) const {
    if (other.m_e)
      // error in second operand, don't combine it
      return *this;
    else {
      vector<string> uris(m_uris);
      uris.insert(uris.end(), other.m_uris.begin(), other.m_uris.end());
      return ObjectResult(m_e, m_parsed+other.m_parsed, uris);
    }
  }

  int getErrorCode() const {
    return m_e;
  }

  const string& getParsedText() const {
    return m_parsed;
  }

  const vector<string>& geAbsoluteURIs() const {
    return m_uris;
  }

  int m_e;
  string m_parsed;
  vector<string> m_uris;
};


// check if it is a valid ontology term uri
pair<int,string> make_builtin_prefixed_ontology_uri(const string& prefix, const string& term)
{
  bool term_is_numeric = IsNumeric(term);
  stringstream ss;
  if (CaselessStrCmp(prefix, "ChEBI") && term_is_numeric) {
    ss << "https://identifiers.org/chebi/CHEBI:" << term;
    return make_pair(0,ss.str());
  } else if (CaselessStrCmp(prefix, "GO") && term_is_numeric) {
    ss << "https://identifiers.org/obo.go/GO:" << term;
    return make_pair(0,ss.str());
  } else if (CaselessStrCmp(prefix, "FMA") && term_is_numeric) {
    ss << "https://identifiers.org/fma/FMA:" << term;
    return make_pair(0,ss.str());
  } else if (CaselessStrCmp(prefix, "OPB") && term_is_numeric) {
    ss << "https://identifiers.org/opb/OPB_" << term;
    return make_pair(0,ss.str());
  } else if (g_registry.IsRegisteredPrefix(prefix) && term_is_numeric) {
    return make_pair(0,g_registry.GetUriForPrefix(prefix));
  } else
    return make_pair(1,"");
}

ObjectResult try_parse_object()
{
  cerr << "      try_parse_object\n";
  char cc = 0;
  string ws = eat_whitespace_and_comments();
  g_registry.input->get(cc);
  // first check if it's a built-in predicate (the biomodels quals) or prefixed predicate
  if (cc > 0 && (isalpha(cc) || cc == '_')) {
    string first_word;
    while (is_word_char(cc) && !g_registry.input->eof()) {
      first_word += cc;
      g_registry.input->get(cc);
    }

    // is a prefixed uri?
    if (cc != ':' || g_registry.input->eof()) {
      putback_string(first_word+":");
      return ObjectResult(2);
    }

    // check the prefixed uri
    string second_word;
    g_registry.input->get(cc);
    while (is_word_char(cc) && !g_registry.input->eof()) {
      second_word += cc;
      g_registry.input->get(cc);
    }
    g_registry.input->unget();

    // look for a comma
    string extra = eat_whitespace();
    g_registry.input->get(cc);
    bool comma = false;
    if (cc == ',') {
      extra += ",";
      comma = true;
    } else
      g_registry.input->unget();

    pair<int,string> uri_result = make_builtin_prefixed_ontology_uri(first_word,second_word);
    if (!uri_result.first) {
      return ObjectResult(0,ws+first_word+":"+second_word+extra,uri_result.second).combine(comma ? try_parse_object() : ObjectResult(10));
    } else {
      putback_string(first_word+":"+second_word+extra);
      return ObjectResult(3);
    }
  } else if (cc == '<') {
    // it could be an absolute uri
    g_registry.input->get(cc);
    string uri;
    while (!is_whitespace(cc) && cc != '>' && !g_registry.input->eof()) {
      uri += cc;
      g_registry.input->get(cc);
    }
    if (cc == '>' && !g_registry.input->eof()) {
      // look for a comma
      string extra = eat_whitespace();
      g_registry.input->get(cc);
      bool comma = false;
      if (cc == ',') {
        extra += ",";
        comma = true;
      } else
        g_registry.input->unget();

      // it is an absolute uri
      return ObjectResult(0,"<"+uri+">",uri).combine(comma ? try_parse_object() : ObjectResult(11));
    }
    else {
      // it's not an absolute uri
      // we don't know what it is so put everything back
      g_registry.input->unget();
      putback_string("<"+uri);
      return ObjectResult(4);
    }
  } else return ObjectResult(5);
}

class PredicatePart
{
public:
  typedef map< string,vector<string> > TermMap;

  // error condition
  PredicatePart(int e)
  : m_e(e) {}

  PredicatePart(int e, const string& ws1, const string ws2, const PredicateResult& predicate, const ObjectResult& object)
  : m_e(e), m_parsed(ws1+predicate.getParsedText()+ws2+object.getParsedText()) {
    string p = predicate.getPredicateAbsoluteURI();
    m_terms_for[p].insert(m_terms_for[p].end(), object.geAbsoluteURIs().begin(), object.geAbsoluteURIs().end());
  }

  PredicatePart combine(const PredicatePart& other) const {
    if (other.m_e)
      // error in second operand, don't combine it
      return *this;
    else {
      PredicatePart new_part(*this);
      new_part.m_parsed += other.m_parsed;
      // merge the maps
      for(TermMap::const_iterator p(other.m_terms_for.begin()); p!=other.m_terms_for.end(); ++p)
        new_part.m_terms_for[p->first].insert(new_part.m_terms_for[p->first].end(), p->second.begin(), p->second.end());
      return new_part;
    }
  }

  int getErrorCode() const {
    return m_e;
  }

  const string& getParsedText() const {
    return m_parsed;
  }

  string toString() const {
    stringstream ss;
    for (TermMap::const_iterator i(m_terms_for.begin()); i!=m_terms_for.end(); ++i) {
      ss << "  " << i->first << ": ";
      for (vector<string>::const_iterator j(i->second.begin()); j!=i->second.end(); ++j) {
        if (j != i->second.begin())
          ss << ", ";
        ss << *j;
      }
      ss << "\n";
    }
    return ss.str();
  }

  int m_e;
  string m_parsed;
  // contains all the objects for a given predicate
  TermMap m_terms_for;
};

// parse multiple predicates if encountered
PredicatePart try_parse_predicate_part()
{
  cerr << "  try_parse_predicate_part\n";
  string ws1 = eat_whitespace();

  // check to see if the next token is a predicate (biomodels qual or prefixed uri)
  PredicateResult predicate_result = try_parse_predicate();
  if (predicate_result.getErrorCode()) {
    putback_string(ws1);
    return PredicatePart(1);
  }

  string ws2 = eat_whitespace();

  // try to parse the object: an ontology term or model entity (in composite annotations)
  ObjectResult object_result = try_parse_object();
  if (object_result.getErrorCode()) {
    putback_string(ws1+predicate_result.getParsedText()+ws2);
    return PredicatePart(2);
  }

  return PredicatePart(0, ws1, ws2, predicate_result, object_result).combine(try_parse_predicate_part());
}

// returns zero if it matches an annotation, non-zero otherwise (and puts back everything it read in the latter)
int try_parse_annotation(char cc)
{
  cerr << "try_parse_annotation\n";

  // annotation should start with a variable name
  if (cc > 0 && (isalpha(cc) || cc == '_')) {
    string word;
    while (cc > 0 && (isalpha(cc) || isdigit(cc) || cc == '_') && !g_registry.input->eof()) {
      word += cc;
      g_registry.input->get(cc);
    }
    g_registry.input->unget();
    cerr << "  " << word << "\n";

    // determine the type of entity
    Module* module = g_registry.GetModule(word);
    Module* current_module = g_registry.CurrentModule();
    Variable* var=NULL;
    if (current_module) {
      vector<string> fullname;
      fullname.push_back(word);
      var = current_module->GetVariable(fullname);
    }
    UserFunction* f = g_registry.GetUserFunction(word);
    if (module || var || f) {
      PredicatePart predicate_part = try_parse_predicate_part();

      if(predicate_part.getErrorCode()) {
        putback_string(word+predicate_part.getParsedText());
        // read the first char again since that's the state we started with
        g_registry.input->get(cc);
        return 2;
      }
      if (f) {
        cerr << "function " << f->GetModuleName() << "\n" << predicate_part.toString();
      } else if (var) {
        cerr << "variable " << var->GetName().at(0) << "\n" << predicate_part.toString();
      } else if (module) {
        cerr << "module " << module->GetModuleName() << "\n" << predicate_part.toString();
      }

      int num_newlines = count_newlines_in(word+predicate_part.getParsedText());
      cerr << num_newlines << " new lines\n";
      antimony_yylloc_last_line += num_newlines;

      return 0;
    } else {
      putback_string(word);
      // read the first char again since that's the state we started with
      g_registry.input->get(cc);
      return 3;
    }
  } else
    return 4;
}

int antimony_yylex(void)
{
  char cc = 0;
  if (g_registry.GetEOFFlag()) {
    g_registry.ClearEOFFlag();
    if (g_registry.SwitchToPreviousFile()) {
      if (g_registry.CurrentModule()->Finalize()) {
        return ERROR;
      }
      return 0;
    }
    else {
      antimony_yylloc_first_line = antimony_yylloc_last_lines.back();
      antimony_yylloc_last_line = antimony_yylloc_last_lines.back();
      antimony_yylloc_last_lines.pop_back();
      return antimony_yylex();
    }
  }
  else {
    g_registry.input->get(cc);
    //If we're done with the file, add a newline
    if (g_registry.input->eof()) {
      g_registry.SetEOFFlag();
      return EOL;
    }
  }
  if (!g_registry.input->good()) {
    //Something else went wrong!
    g_registry.SetError("Unparseable content in line " + DoubleToString(antimony_yylloc_last_line) + ".");
    return ERROR;
  }

  antimony_yylloc_first_line = antimony_yylloc_last_line;

  // Skip white space.
  while ((cc == ' ' ||
         cc == '\t') &&
         !g_registry.input->eof()) {
    g_registry.input->get(cc);
  }
  if (g_registry.input->eof()) return antimony_yylex();
  // Skip carriage returns after '\':
  if (cc == '\\') {
    g_registry.input->get(cc);
    if (cc == '\r' || cc == '\n' || cc == ' ') {
      while ((cc == '\r' || cc == '\n' || cc == ' ') && !g_registry.input->eof()) {
        g_registry.input->get(cc);
      }
      ++antimony_yylloc_last_line;
      g_registry.input->unget();
      return antimony_yylex();
    }
    else {
      g_registry.input->unget();
      cc = '\\';
    }
 }

  // try to parse annotations (does not change state if not found)
//   cerr << "before: " << (char)g_registry.input->peek() << "\n";
  int parsed_annot = 0;
  while (!parsed_annot) {
    char next = g_registry.input->peek();
    parsed_annot = try_parse_annotation(cc);
    // if success, try again until no more annotations left
    if (!parsed_annot) {
      g_registry.input->get(cc);
    }
    cerr << "  ->" << cc << (char)g_registry.input->peek() << "\n";
    if ((next != g_registry.input->peek()) && parsed_annot) {
      cerr << "next was " << next << " vs. " << (char)g_registry.input->peek() <<
      "(" << g_registry.input->peek() << ")" <<
      "\n";
      assert(false);
    }
  }

  // Parse words
  if (cc > 0 && cc < 256 && (isalpha(cc) || cc == '_')) {
    string word;
    while (cc > 0 && (isalpha(cc) || isdigit(cc) || cc == '_') && !g_registry.input->eof()) {
      word += cc;
      g_registry.input->get(cc);
    }
    if (!g_registry.input->eof()) {
      g_registry.input->unget();
    }
    if (CaselessStrCmp(word, "module")) {
      return MODULE;
    }
    if (CaselessStrCmp(word, "model")) {
      return MODULE;
    }
    if (CaselessStrCmp(word, "end")) {
      return END;
    }
    if (CaselessStrCmp(word, "species")) {
      return SPECIES;
    }
    if (CaselessStrCmp(word, "formula")) {
      return FORMULA;
    }
    if (CaselessStrCmp(word, "reaction")) {
      return REACTION;
    }
    if (CaselessStrCmp(word, "DNA")) {
      return DNA;
    }
    if (CaselessStrCmp(word, "gene")) {
      return GENE;
    }
    if (CaselessStrCmp(word, "operator")) {
      return OPERATOR;
    }
    if (CaselessStrCmp(word, "compartment")) {
      return COMPARTMENT;
    }
    if (CaselessStrCmp(word, "has")) {
      return HASWORD;
    }
    if (CaselessStrCmp(word, "in")) {
      return INWORD;
    }
    if (CaselessStrCmp(word, "is")) {
      return IS;
    }
    if (CaselessStrCmp(word, "var")) {
      return VARWORD;
    }
    if (CaselessStrCmp(word, "const")) {
      return CONSTWORD;
    }
    if (CaselessStrCmp(word, "substanceOnly")) {
      return SUBSTONLY;
    }
    if (CaselessStrCmp(word, "ext")) {
      return CONSTWORD;
    }
    if (CaselessStrCmp(word, "import")) {
      return IMPORT;
    }
    if (CaselessStrCmp(word, "event")) {
      return EVENT;
    }
    if (CaselessStrCmp(word, "at")) {
      return AT;
    }
    if (CaselessStrCmp(word, "after")) {
      return AFTER;
    }
    if (CaselessStrCmp(word, "function")) {
      return FUNCTIONWORD;
    }
    if (CaselessStrCmp(word, "unit")) {
      return UNITWORD;
    }
    if (CaselessStrCmp(word, "delete")) {
      return DELETEWORD;
    }
    if (CaselessStrCmp(word, "constraint")) {
      return CONSTRAINTWORD;
    }
    if (CaselessStrCmp(word, "maximize")) {
      return MAXIMIZEWORD;
    }
    if (CaselessStrCmp(word, "minimize")) {
      return MINIMIZEWORD;
    }
    if (CaselessStrCmp(word, "sbo") && (g_registry.input->peek() == ':')) {
      // try to parse an SBO term
      g_registry.input->get();
      cc = g_registry.input->peek();
      if (cc > 0 && cc < 256 && (isdigit(cc))) {
        *g_registry.input >> antimony_yylval.integer;
        if (g_registry.input->fail()) {
          g_registry.SetError("Unable to parse SBO term.");
          return ERROR;
        }
        antimony_yylval.num = antimony_yylval.integer;
        antimony_yylval.is_integer = true;
      }
      return NUM;
    }
    
    if (g_registry.IsFunction(word) != NULL) {
      antimony_yylval.word = g_registry.IsFunction(word);
      return FUNCTION;
    }
    if (g_registry.IsConstant(word) != NULL) {
      antimony_yylval.word = g_registry.IsConstant(word);
      return CONSTANT;
    }
    //Otherwise, it's a user-defined variable:
    antimony_yylval.word = g_registry.AddWord(word);
    //cout << "\tRead word '" << word << "'." << endl;
    if (g_registry.IsModuleName(word)) {
      return MODNAME;
    }
    return ANTWORD;
  }

  // Parse numbers
  if (cc > 0 && cc < 256 && (isdigit(cc) || (cc=='.' && isdigit(g_registry.input->peek())))) {
    double number;
    g_registry.input->unget();
    streampos numbegin = g_registry.input->tellg();
    *g_registry.input >> number;
    streampos numend = g_registry.input->tellg();
    if (g_registry.input->fail()) {
      //The gcc 4.4.3 parser fails if there's an 'e' after a number with no exponent.
      g_registry.input->clear();
      g_registry.input->seekg(numbegin);
      int numint;
      *g_registry.input >> numint;
      antimony_yylval.num = numint;
      antimony_yylval.integer = numint;
      antimony_yylval.is_integer = true;
      if (g_registry.input->peek() == '.') {
        antimony_yylval.integer = 0;
        antimony_yylval.is_integer = false;
        g_registry.input->get();
        *g_registry.input >> numint;
        double fraction = numint;
        while (fraction >= 1.0) {
          fraction = fraction/10;
        }
        antimony_yylval.num += fraction;
      }
      return NUM;
    }
    assert(g_registry.input->good());
    antimony_yylval.num = number;
    //However, pre-4.4.3 parsers would read the 'e' anyway, and we don't want it to, so unget the 'e'.
    g_registry.input->unget();
    if (!g_registry.input->good()) {
      //Sometimes you can't do this?  For some reason?  If this happens we'll assume there was no 'e'.
      g_registry.input->clear();
    }
    else {
      g_registry.input->get(cc);
      if (cc == 'e' || cc == 'E') {
        g_registry.input->unget();
      }
    }
    return NUM;
  }

  //Parse '->' and dashes
  if (cc == '-') {
    g_registry.input->get(cc);
    if (cc == '-') {
      while ((cc == '-') && !g_registry.input->eof()) {
        g_registry.input->get(cc);
      }
      g_registry.input->unget();
      return DASHES;
    } else if (cc == '>') {
      return BECOMESREV;
    } else if (cc == '|') {
      return BECOMESINH;
    } else if (cc == '(') {
      return BECOMESMOD;
    } else if (cc == 'o') {
      return BECOMESMOD2;
    }
    g_registry.input->unget();
    cc = '-';
    return cc;
  }

  //Parse '=>'
  if (cc == '=') {
    g_registry.input->get(cc);
    if (cc == '>') {
      return BECOMESIRREV;
    }
    g_registry.input->unget();
    cc = '=';
    return cc;
  }

  //Skip comments:
  if (cc == '/') {
    g_registry.input->get(cc);
    if (cc == '/') {
      while (cc != '\n' && cc != '\r' && !g_registry.input->eof()) {
        g_registry.input->get(cc);
      }
      if (!g_registry.input->eof()) {
        g_registry.input->unget();
      }
      return antimony_yylex();
    }
    else if (cc == '*') {
      bool nextstar = false;
      g_registry.input->get(cc);
      while ((!g_registry.input->eof()) && !(nextstar && cc == '/')) {
        if (cc == '*') {
          nextstar = true;
        }
        else {
          nextstar = false;
        }
        g_registry.input->get(cc);
      }
      return antimony_yylex();
    }
    else {
      g_registry.input->unget();
      cc = '/';
    }
  }
  else if (cc == '#') {
      while (cc != '\n' && cc != '\r' && !g_registry.input->eof()) {
        g_registry.input->get(cc);
      }
      if (!g_registry.input->eof()) {
        g_registry.input->unget();
      }
      return antimony_yylex();
  }

  //Parse ellipses
  if (cc == '.') {
    char c1, c2;
    g_registry.input->get(c1);
    g_registry.input->get(c2);
    if (c1=='.' && c2=='.') {
      return ELLIPSES;
    }
    g_registry.input->unget();
    g_registry.input->unget();
  }

  //Parse text strings
  if (cc == '"') {
    string textstring;
    long ccount = 0;
    g_registry.input->get(cc);
    while (cc != '"' && cc != '\r' && cc != '\n' && !g_registry.input->eof()) {
      textstring += cc;
      ccount++;
      g_registry.input->get(cc);
    }
    if (cc == '\r' || cc == '\n' || g_registry.input->eof()) {
      for (; ccount > 0; ccount--) {
        g_registry.input->unget();
      }
      cc = '"';
    }
    else {
      antimony_yylval.word = g_registry.AddWord(textstring);
      return TEXTSTRING;
    }
  }

//   //Parse uris
//   if (cc == '<') {
//     static string uristring;
//     long ccount = 0;
//     g_registry.input->get(cc);
//     while (cc != '>' && cc != '\r' && cc != '\n' && !g_registry.input->eof()) {
//       uristring += cc;
//       ccount++;
//       g_registry.input->get(cc);
//     }
//     if (cc == '\r' || cc == '\n' || g_registry.input->eof()) {
//       for (; ccount > 0; ccount--) {
//         g_registry.input->unget();
//       }
//       cc = '>';
//     }
//     else {
//       antimony_yylval.word = &uristring;
//       return URI;
//     }
//   }

  //Parse '@'
  if (cc == '@') {
    return AT;
  }

  //This converts PC and Mac end-of-line characters to \n:
  if (cc == '\r') {
    g_registry.input->get(cc);
    if (cc != '\n') {
      g_registry.input->unget();
    }
    cc = '\n';
  }
  if (cc == '\n') {
    ++antimony_yylloc_last_line;
  }
  return cc;
}
