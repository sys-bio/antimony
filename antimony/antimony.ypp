/* Infix notation calculator. */

%{
  //#define YYSTYPE double
#include <math.h>
#include <stdio.h>
#include <string>
#include <ctype.h>
#include <fstream>
#include <iostream>
#include <set>

#include "antimony_api.h"
#include "registry.h"
#include "rd_type.h"
#include "stringx.h"
#include "module.h"

  class Formula;
  class ReactantList;
  class Reaction;
  class Variable;

  using namespace std;
  int yylex(void);
  void yyerror(char const *);
  bool CaselessStrCmp(const string& lhs, const string& rhs);
  Registry g_registry;
%}

/*Bison declarations */
%union {
  char character;
  const string* word;
  double num;
  rd_type reactionDivider;
  Formula* formula;
  Module* module;
  ReactantList* reactantList;
  Reaction* reaction;
  Variable* variable;
  Variable* localvariable;
}

%type <character> mathThing
%type <formula> formula
%type <module> module
%type <reactantList> reactantList
%type <reaction> reaction
%type <reactionDivider> reactionDivider
%type <variable> variable localvariable

%left '(' ')' '+' '-' '*' '/' '^'

%token <num> NUM
%token <word> WORD MODNAME
%token <word> MODULE END BECOMES INHIBITS ACTIVATES INFLUENCES SPECIES PROTEIN DNA GENE PROMOTER OPERATOR VAR CONST DASHES ELLIPSES

%debug
%error-verbose

%% /* The grammar: */

input:          /* empty */
        |       input module { /*cout << endl << $2->ToString() << endl << endl;*/ }
        |       input modulepart {}
        |       input error {cerr << "Error line " << @2.last_line << ": stopping." << endl; YYABORT} 
        ;

module:         MODULE WORD {g_registry.NewCurrentModule($2);} '(' variableexportlist ')' modulebody END
                {
                  $$ = g_registry.CurrentModule();
                  $$->CompileExportLists();
                  g_registry.RevertToPreviousModule();
                }
        |       MODULE WORD {g_registry.NewCurrentModule($2);} modulebody END
                {
                  $$ = g_registry.CurrentModule();
                  $$->CompileExportLists();
                  g_registry.RevertToPreviousModule();
                }
        ;

variableexportlist:
                /* empty */ {}
        |       variable {g_registry.AddVariableToCurrentExportList($1); }
        |       variableexportlist ',' variable { g_registry.AddVariableToCurrentExportList($3); }
        ;

variable:       WORD {$$ = g_registry.AddVariableToCurrent($1); }
        |       variable '.' WORD {$$ = $1->GetSubVariable($3);
                  if ($$ == NULL) {
                    g_registry.SetError("'" + *($3) + "' is not a subvariable of '" + $1->GetNameDelimitedBy('.') + "'.");
                    YYABORT;
                  }
                }
        |       '<' variable '>' {$$ = $2; if ($$->SetIsConst(true)) YYABORT;}
        ;

//Nothing here needs to actually do anything, since we've already added these
// things to the current module.
modulebody:     modulepart {}
        |       modulebody modulepart {}
        ;

modulepart:     reaction lineend {}
        |       assignment lineend {}
        |       submodule lineend {}
        |       varinitialize lineend {}
        |       dnastrand lineend {}
        |       lineend {}
        ;

reaction:       variable ':' { g_registry.CurrentModule()->SetReactionVariable($1); } reactantList reactionDivider reactantList ';' formula
                {
                  $$ = g_registry.AddNewReactionToCurrent($4, $5, $6, $8, g_registry.CurrentModule()->GetReactionVariable());
                  if ($$ == NULL) YYABORT;
                }
        |       reactantList reactionDivider reactantList ';' formula
                {
                  $$ = g_registry.AddNewReactionToCurrent($1, $2, $3, $5);
                  if ($$ == NULL) YYABORT;
                }
        ;

reactantList:   /* empty */ {$$ = g_registry.NewBlankReactantList(); }
        |       variable {$$ = g_registry.NewBlankReactantList(); $$->AddReactant($1); }
        |       NUM variable {$$ = g_registry.NewBlankReactantList(); $$->AddReactant($2, $1); }
        |       reactantList '+' variable {$$ = $1; $1->AddReactant($3); }
        |       reactantList '+' NUM variable {$$ = $1; $1->AddReactant($4, $3); }
        ;

reactionDivider:
                BECOMES   {$$ = rdBecomes;}
        |       INHIBITS  {$$ = rdInhibits;}
        |       ACTIVATES {$$ = rdActivates;}
        |       INFLUENCES  {$$ = rdInfluences;}
        ;

formula:        /* empty */ {$$ = g_registry.NewBlankFormula(); }
        |       ELLIPSES {$$ = g_registry.NewBlankFormula(); $$->AddEllipses();}
        |       variable {$$ = g_registry.NewBlankFormula(); $$->AddVariable($1); }
        |       NUM  {$$ = g_registry.NewBlankFormula(); $$->AddNum($1); }
        |       mathThing {$$ = g_registry.NewBlankFormula(); $$->AddMathThing($1); }
        |       formula variable {$$ = $1; $1->AddVariable($2); }
        |       formula NUM  {$$ = $1; $1->AddNum($2); }
        |       formula mathThing {$$ = $1; $1->AddMathThing($2); }
        ;

mathThing:      '+' {$$ = '+';}
        |       '-' {$$ = '-';}
        |       '*' {$$ = '*';}
        |       '/' {$$ = '/';}
        |       '(' {$$ = '(';}
        |       ')' {$$ = ')';}
        |       '^' {$$ = '^';}
        |       ',' {$$ = ',';}
        ;

lineend:        ';' {}
        |       '\n' {}
        ;

assignment:     variable '=' { g_registry.SetAssignmentVariable($1); } formula {if (g_registry.GetAssignmentVariable()->SetFormula($4)) YYABORT; }
        ;

submodule:      variable ':' MODNAME '(' {if ($1->ImportModule($3)) YYABORT;} variableimportlist ')'
        |       MODNAME '(' {if(g_registry.CurrentModule()->ImportModule($1)) YYABORT;} variableimportlist ')'
        ;
variableimportlist:
                /* empty */ {}
        |       variable {if (g_registry.AddVariableToCurrentImportList($1)) YYABORT; }
        |       variableimportlist ',' variable { if (g_registry.AddVariableToCurrentImportList($3)) YYABORT; }
        |       variableimportlist ',' variable '=' localvariable {if ($3->Synchronize($5)) YYABORT; }
        ;

localvariable:  WORD {$$ = g_registry.GetImportedModuleSubVariable($1); }
        |       localvariable '.' WORD {$$ = $1->GetSubVariable($3); }
        ;

varinitialize:  specinit { }
        |       protinit { }
        |       dnainit { }
        |       geneinit { }
        |       promoterinit { }
        |       operatorinit { }
        |       constprotinit { }
        |       constgeneinit { }
        |       constpromoterinit { }
        |       constoperatorinit { }
        |       constinit { }
        ;

specinit:       SPECIES variable {if ($2->SetType(varSpeciesUndef)) YYABORT; }
        |       VAR SPECIES variable {if ($3->SetType(varSpeciesUndef)) YYABORT; }
        |       specinit ',' variable {if ($3->SetType(varSpeciesUndef)) YYABORT; }
        ;

protinit:       PROTEIN variable {if ($2->SetType(varSpeciesProtein)) YYABORT; }
        |       VAR PROTEIN variable {if ($3->SetType(varSpeciesProtein)) YYABORT; }
        |       protinit ',' variable {if ($3->SetType(varSpeciesProtein)) YYABORT; }
        ;

dnainit:        DNA variable {if ($2->SetType(varDNA)) YYABORT; }
        |       VAR DNA variable {if ($3->SetType(varDNA)) YYABORT; }
        |       dnainit ',' variable {if ($3->SetType(varDNA)) YYABORT; }
        ;

geneinit:       GENE variable {if ($2->SetType(varReactionGene)) YYABORT; }
        |       VAR GENE variable {if ($3->SetType(varReactionGene)) YYABORT; }
        |       geneinit ',' variable {if ($3->SetType(varReactionGene)) YYABORT; }
        ;

promoterinit:   PROMOTER variable {if ($2->SetType(varFormulaPromoter)) YYABORT; }
        |       VAR PROMOTER variable {if ($3->SetType(varFormulaPromoter)) YYABORT; }
        |       promoterinit ',' variable {if ($3->SetType(varFormulaPromoter)) YYABORT; }
        ;

operatorinit:   OPERATOR variable {if ($2->SetType(varFormulaOperator)) YYABORT; }
        |       VAR OPERATOR variable {if ($3->SetType(varFormulaOperator)) YYABORT; }
        |       operatorinit ',' variable {if ($3->SetType(varFormulaOperator)) YYABORT; }
        ;

constprotinit:  CONST PROTEIN variable {if ($3->SetType(varSpeciesProtein)) YYABORT;
                                        if ($3->SetIsConst(true)) YYABORT;}
        |       constprotinit ',' variable {if ($3->SetType(varSpeciesProtein)) YYABORT; 
                                            if ($3->SetIsConst(true)) YYABORT;}
        ;

constgeneinit:  CONST GENE variable {if ($3->SetType(varReactionGene)) YYABORT; 
                                     if ($3->SetIsConst(true)) YYABORT;}
        |       constgeneinit ',' variable {if ($3->SetType(varReactionGene)) YYABORT; 
                                            if ($3->SetIsConst(true)) YYABORT;}
        ;

constpromoterinit:
                CONST PROMOTER variable {if ($3->SetType(varFormulaPromoter)) YYABORT; 
                                         if ($3->SetIsConst(true)) YYABORT;}
        |       constpromoterinit ',' variable {if ($3->SetType(varFormulaPromoter)) YYABORT; 
                                                if ($3->SetIsConst(true)) YYABORT;}
        ;

constoperatorinit:
                CONST OPERATOR variable {if ($3->SetType(varFormulaOperator)) YYABORT; 
                                         if ($3->SetIsConst(true)) YYABORT;}
        |       constoperatorinit ',' variable {if ($3->SetType(varFormulaOperator)) YYABORT; 
                                                if ($3->SetIsConst(true)) YYABORT;}
        ;

constinit:      CONST variable {if ($2->SetIsConst(true)) YYABORT;}
        |       constinit ',' variable {if ($3->SetIsConst(true)) YYABORT;}
        ;

dnastrand:      DASHES variable {if (g_registry.SetNewUpstreamOpen($2)) YYABORT;}
        |       DASHES dnamiddle {g_registry.GetWorkingStrand()->SetOpenUpstream(); }
        |       dnamiddle variable {if (g_registry.SetDownstreamEnd($2)) YYABORT;}
        |       DASHES dnamiddle variable {g_registry.GetWorkingStrand()->SetOpenUpstream(); if(g_registry.SetDownstreamEnd($3)) YYABORT;}
        |       dnamiddle { }
        ;

dnamiddle:      variable DASHES {g_registry.SetNewDownstreamOpen($1);}
        |       dnamiddle variable DASHES {g_registry.SetDownstreamOpen($2);}
        ;

%%


void yyerror(char const *s)
{
  g_registry.SetError("Error parsing line " + ToString(yylloc.last_line) + ":  " + s);
}

int yylex(void)
{
  //If we're done with the file:
  if (g_registry.input.eof()) {
    return 0;
  }
  if (!g_registry.input.good()) {
    //Something else went wrong!
    g_registry.SetError("The input file is no longer good, for an unknown reason.");
    return -1;
  }

  char cc = 0;
  g_registry.input.get(cc);

  yylloc.first_line = yylloc.last_line;

  // Skip white space.
  while (cc == ' ' ||
         cc == '\t') {
    g_registry.input.get(cc);
  }

  // Parse words
  if (isalpha(cc) || cc == '_') {
    string word;
    while (isalpha(cc) || isdigit(cc) || cc == '_') {
      word += cc;
      g_registry.input.get(cc);
    }
    g_registry.input.unget();
    if (CaselessStrCmp(word, "module")) {
      return MODULE;
    }
    if (CaselessStrCmp(word, "model")) {
      return MODULE;
    }
    if (CaselessStrCmp(word, "end")) {
      return END;
    }
    if (CaselessStrCmp(word, "species")) {
      return SPECIES;
    }
    if (CaselessStrCmp(word, "protein")) {
      return PROTEIN;
    }
    if (CaselessStrCmp(word, "DNA")) {
      return DNA;
    }
    if (CaselessStrCmp(word, "gene")) {
      return GENE;
    }
    if (CaselessStrCmp(word, "promoter")) {
      return PROMOTER;
    }
    if (CaselessStrCmp(word, "operator")) {
      return OPERATOR;
    }
    if (CaselessStrCmp(word, "var")) {
      return VAR;
    }
    if (CaselessStrCmp(word, "const")) {
      return CONST;
    }
    if (CaselessStrCmp(word, "ext")) {
      return CONST;
    }
    //Otherwise, it's a user-defined variable:
    yylval.word = g_registry.AddWord(word);
    //cout << "\tRead word '" << word << "'." << endl;
    if (g_registry.IsModuleName(word)) {
      return MODNAME;
    }
    return WORD;
  }

  // Parse numbers
  if (isdigit(cc)) {
    double number;
    g_registry.input.unget();
    g_registry.input >> number;
    yylval.num = number;
    //Now check to see if the last thing read was an 'E'/'e'
    g_registry.input.unget();
    g_registry.input.get(cc);
    if (cc == 'e' || cc == 'E') {
      g_registry.input.unget();
    }
    return NUM;
  }

  //Parse reaction dividers and dashes
  if (cc == '-') {
    g_registry.input.get(cc);
    if (cc == '>') {
      return BECOMES;
    }
    if (cc == '|') {
      return INHIBITS;
    }
    if (cc == 'o') {
      return ACTIVATES;
    }
    if (cc == '(') {
      return INFLUENCES;
    }
    if (cc == '-') {
      while (cc == '-') {
        g_registry.input.get(cc);
      }
      g_registry.input.unget();
      return DASHES;
    }
    g_registry.input.unget();
    cc = '-';
    return cc;
  }

  //Skip comments:
  if (cc == '/') {
    g_registry.input.get(cc);
    if (cc == '/') {
      while (cc != '\n' && cc != '\r') {
        g_registry.input.get(cc);
      }
    }
    else {
      g_registry.input.unget();
      cc = '/';
    }
  }

  //Parse ellipses
  if (cc == '.') {
    char c1, c2;
    g_registry.input.get(c1);
    g_registry.input.get(c2);
    if (c1=='.' && c2=='.') {
      return ELLIPSES;
    }
    g_registry.input.unget();
    g_registry.input.unget();
  }

  //This converts PC and Mac end-of-line characters to \n:
  if (cc == '\r') {
    g_registry.input.get(cc);
    if (cc != '\n') {
      g_registry.input.unget();
    }
    cc = '\n';
  }
  if (cc == '\n') {
    ++yylloc.last_line;
  }
  return cc;
}

bool CaselessStrCmp(const string& lhs, const string& rhs)
{

  if (lhs.size() != rhs.size()) return false;

  for (size_t i = 0; i < lhs.size(); ++i) {
    if (toupper(lhs[i]) != toupper(rhs[i])) return false;
  }
  return true;

} /* CaselessStrCmp */

int main(long argc, char** argv)
{
  string filename="input.txt";
  if (argc > 2) {
    cout << "Cannot parse more than one file." << endl;
    return 0;
  }
  else if (argc == 2) {
    filename = argv[1];
  }
  //yydebug = 1;
  int retval=loadModel(filename.c_str());
  if (retval) {
    cout << "Error:  " << g_registry.GetError().c_str() << endl;
  }
  else {
    size_t nummods = getNumModules();
    char** modnames = getModuleNames();
    for (size_t mod=0; mod<nummods; mod++) {
      cout << "Information for module '" << modnames[mod] << "'" << endl;
      cout << "***ToString (" << modnames[mod] << ") ***" << endl;
      cout << g_registry.GetModule(modnames[mod])->ToString().c_str() << endl << endl;
      cout << "***Jarnac (" << modnames[mod] << ") ***" << endl;
      cout << getJarnac(modnames[mod]) << endl;
      cout << endl << "***printAllDataFor (" << modnames[mod] << ") (from the API):***" << endl;
      printAllDataFor(modnames[mod]);
      cout << endl;
      cout << endl;
    }
  }
  freeAll();
  return retval;
}
